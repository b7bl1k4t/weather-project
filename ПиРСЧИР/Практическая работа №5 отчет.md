# Практическая работа №5. Сессии, cookies и файловое хранилище

## Реализованный функционал
1. **Хранение сессий в Redis.** Добавлен контейнер Redis и настроен PHP-нагрузчик `phpredis`. Сессии приложения перенесены в Redis через единый bootstrap-файл; включены безопасные параметры cookie и расширен срок жизни сессии.
2. **Персонализация контента.** На странице `/index.php` появился блок пользовательских настроек. Логин, тема интерфейса (светлая, тёмная, контрастная) и язык (RU/EN/ES) сохраняются параллельно в Redis и cookie на 30 дней. Выбор влияет на приветствие, локализацию текста и тему оформления.
3. **Работа с PDF-файлами.** Реализована форма загрузки PDF (до 5 МБ). Файлы сохраняются в файловой системе контейнера, сопроводительные метаданные — в `dynamic/uploads/uploads_meta.json`. Для каждого файла доступна выдача по ссылке `/download.php?id=...`.
4. **UI-обновления.** Добавлены уведомления о результате операций, адаптивные карточки настроек и материалов, поддержка CSS-переменных для тем оформления.

## Проверка работоспособности
1. Собрать и запустить окружение: `docker compose up --build`.
2. Перейти на `http://localhost/index.php`.
3. Убедиться, что в Redis создаются сессионные ключи (можно выполнить `docker exec -it weather_redis redis-cli keys '*'`).
4. В форме «Персональные настройки» указать логин, тему и язык. После отправки страница должна обновиться, фон и подписи сменят оформление, в браузере появятся cookie `weather_login`, `weather_theme`, `weather_language`.
5. Загрузить любой PDF-файл до 5 МБ. В списке материалов появится новая запись со ссылкой «Скачать», загрузка по ссылке возвращает исходный файл.
6. В административной форме добавить новую запись о погоде и убедиться, что данные отображаются в блоках «Текущая погода» и «История погоды».

## Ответы на вопросы
1. **Сессия** в веб-разработке — это набор данных о пользователе, хранимый на сервере между запросами и идентифицируемый с помощью session-id в cookie или URL.
2. **Cookie** — это небольшие фрагменты данных, которые сервер отправляет браузеру; браузер сохраняет их и возвращает при следующих запросах к тому же домену.
3. Механизм cookie: сервер задаёт cookie через заголовок `Set-Cookie`, браузер сохраняет пару «ключ-значение» вместе с параметрами (домен, путь, срок жизни, secure, httpOnly, SameSite) и автоматически добавляет `Cookie:` к каждому подходящему запросу.
4. Пример сессии в PHP: `session_start(); $_SESSION['user_id']=42; echo $_SESSION['user_id'];` — данные сохранятся между запросами, пока есть валидный session-id.
5. Защита сессий включает передачу идентификатора по HTTPS, установку `httpOnly` и `SameSite`, регенерацию id после входа, ограничение времени жизни, привязку к User-Agent/IP, проверку CSRF-токенов и хранение сессий в надёжном бекенде.
6. Да, данные сессии можно хранить в БД (SQL/NoSQL/Redis). Это упрощает горизонтальное масштабирование и централизованное управление сроком жизни.
7. Жизненный цикл сессии: создание идентификатора → сохранение данных → использование между запросами → возможная регенерация id → истечение (по тайм-ауту или явное уничтожение) и удаление данных.
8. Механизм сессий можно выключить, но тогда всю идентификацию и состояние придётся реализовывать вручную, что редко оправдано.
9. Примеры настройки сессии во время выполнения: `ini_set('session.cookie_lifetime', 86400); session_set_cookie_params([...]); session_name('custom'); session_regenerate_id(true);`.
10. Директивы конфигурации файловой системы/потоков в PHP: `allow_url_fopen`, `allow_url_include`, `open_basedir`, `user_ini.filename`, `auto_detect_line_endings`, настройка стрим-врапперов через `register_stream_wrapper`.
11. Файловая система в PHP работает с ресурсами типа `resource stream`. Это обёртка над дескриптором файла/сокета/потока, предоставляющая функции чтения/записи (`fopen`, `fread`, `fwrite` и т.д.).
12. Чтобы открыть файл: `$handle = fopen('file.txt', 'r');`, закрыть — `fclose($handle);`.
13. Чтение — `fread`, `fgets`, `file_get_contents`; запись — `fwrite`, `file_put_contents` или использование режимов `w`, `a` в `fopen`.
14. Считать часть файла: `fread($handle, $length)`; последовательно — цикл `while (!feof($handle)) { fgets(...) }`; полностью — `file_get_contents` или чтение в буфер до EOF.
15. Создание файла: `fopen('new.txt','w')` либо `touch`; удаление — `unlink('file.txt')`.
16. Информация о файле: `filesize`, `filemtime`, `fileperms`, `is_readable`, `stat`, `SplFileInfo` и т.д.
17. **DOM** (Document Object Model) — объектное представление структуры XML/HTML-документа в виде дерева узлов.
18. Работа с DOM в PHP: `new DOMDocument(); $doc->loadXML($xml);` для парсинга, `createElement`, `appendChild` для построения, `save`/`saveXML` для сохранения.
19. **JSON** — текстовый формат обмена данными, основанный на литералах JavaScript (объекты и массивы).
20. Декодировать строку JSON: `json_decode($json, true);` Вернуть JSON-представление: `json_encode($data, JSON_UNESCAPED_UNICODE);`.
21. Проверка ошибок JSON: сразу после `json_decode` вызвать `json_last_error()` или `json_last_error_msg()`; при `json_encode` ловить `false` и анализировать `json_last_error`.
22. XML в PHP: создать `DOMDocument`, наполнять элементами, `save` в файл. Для чтения — `load`, обходить дерево, `DOMXPath` для запросов.
23. Драйвер СУБД — программный модуль, реализующий протокол взаимодействия приложения с конкретной БД (например, `pdo_pgsql`, `mysqli`, `mongodb` driver).
24. Добавление записи через `mysqli`: `$stmt = $mysqli->prepare('INSERT INTO users(name) VALUES (?)'); $stmt->bind_param('s', $name); $stmt->execute();`.
25. Постоянное соединение (`p:` в хосте `mysqli`) не закрывается после запроса, что снижает накладные расходы, но может вести к зависшим коннектам; решается контролем тайм-аутов и корректным использованием пула.
26. MongoDB — документо-ориентированная NoSQL СУБД, хранит BSON-документы, масштабируется горизонтально, поддерживает гибкую схему и встроенный шардирование/репликацию.
27. Добавление записи MongoDB в PHP (driver): `$collection = (new MongoDB\Client)->db->collection; $collection->insertOne(['name' => 'City']);`.
28. Получение записей MongoDB: `$collection->find([...])`, далее итерируем курсор, применяем фильтры/сортировки, приводим к нужному формату.
29. Получение записей через `mysqli`: `SELECT ...`, затем `query`/`prepare`, `bind_result` и цикл `fetch`.
30. В MongoDB поиск/подсчёт/ограничение выборки: `find($filter, ['limit' => 10, 'skip' => 5])`, `countDocuments($filter)`, `findOne`, использование операторов `$regex`, `$gt`, `$lte`, `$in` для гибкой фильтрации.
